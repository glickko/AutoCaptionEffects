import sys, os, re, subprocess, json, time, logging
from datetime import timedelta
import numpy as np
from moviepy.editor import VideoFileClip, CompositeVideoClip, TextClip, ColorClip, ImageClip, AudioFileClip
from PIL import Image, ImageColor

# Patch untuk mengatasi error PIL.Image.ANTIALIAS (Pillow 10+)
if not hasattr(Image, "ANTIALIAS"):
    Image.ANTIALIAS = Image.Resampling.LANCZOS

import cv2  # Pastikan modul opencv-python sudah terinstal

logging.basicConfig(level=logging.INFO,
                    format="%(asctime)s %(levelname)s:%(message)s",
                    handlers=[logging.FileHandler("subtitle_app.log"),
                              logging.StreamHandler()])

import moviepy.config as cfg
DEFAULT_IMAGEMAGICK_PATH = r"C:\Program Files\ImageMagick-7.1.1-Q16-HDRI\magick.exe"
IMAGEMAGICK_PATH = DEFAULT_IMAGEMAGICK_PATH
cfg.IMAGEMAGICK_BINARY = IMAGEMAGICK_PATH

def get_imagemagick_fonts(im_path=None):
    im_path = im_path or IMAGEMAGICK_PATH
    try:
        output = subprocess.check_output([im_path, "-list", "font"], stderr=subprocess.STDOUT).decode("utf-8")
        fonts = []
        for line in output.splitlines():
            line = line.strip()
            if line.startswith("Font:"):
                parts = line.split(":", 1)
                if len(parts) > 1:
                    fonts.append(parts[1].strip())
        if not fonts:
            fonts = ["Helvetica-Bold", "Arial", "Times-New-Roman"]
        return fonts
    except Exception as e:
        logging.error("Error getting fonts: %s", e)
        return ["Helvetica-Bold", "Arial", "Times-New-Roman"]

def sanitize_filename(name):
    return re.sub(r'[\\/*?:"<>|]', "_", name)

import whisper
import torch
import ffmpeg
import srt

from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout, QGroupBox,
    QPushButton, QFileDialog, QLabel, QProgressBar, QLineEdit, QSpinBox,
    QMessageBox, QComboBox, QCheckBox, QTabWidget, QPlainTextEdit, QDoubleSpinBox, QScrollArea
)
from PyQt6.QtCore import QSettings, Qt

# Fungsi untuk membuat mask rounded corner (overlay highlight)
def create_rounded_overlay(size, color, radius=10, duration=1, opacity=0.8):
    w, h = size
    mask = np.zeros((h, w), dtype=np.uint8)
    cv2.rectangle(mask, (radius, 0), (w - radius, h), 255, -1)
    cv2.rectangle(mask, (0, radius), (w, h - radius), 255, -1)
    cv2.circle(mask, (radius, radius), radius, 255, -1)
    cv2.circle(mask, (w - radius, radius), radius, 255, -1)
    cv2.circle(mask, (radius, h - radius), radius, 255, -1)
    cv2.circle(mask, (w - radius, h - radius), radius, 255, -1)
    if isinstance(color, str):
        color = ImageColor.getrgb(color)
    solid = np.zeros((h, w, 4), dtype=np.uint8)
    solid[..., 0] = color[0]
    solid[..., 1] = color[1]
    solid[..., 2] = color[2]
    alpha = (mask.astype(np.float32) / 255.0) * (opacity * 255)
    solid[..., 3] = alpha.astype(np.uint8)
    overlay = ImageClip(solid, duration=duration)
    return overlay

def export_ass_file(subtitles, output_ass, playresx=1280, playresy=720, 
                    font="Helvetica-Bold", fontsize=40, primary_color="&H00FFFFFF"):
    header = "[Script Info]\n; Script generated by SubtitleApp\nTitle: Subtitle Output\nScriptType: v4.00+\nCollisions: Normal\n"
    header += f"PlayResX: {playresx}\nPlayResY: {playresy}\nTimer: 100.0\n\n"
    header += "[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n"
    header += f"Style: Default,{font},{fontsize},{primary_color},&H000000FF,&H00000000,&H64000000,0,0,0,0,100,100,0,0,1,2,0,2,10,10,10,1\n\n"
    header += "[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n"
    events = ""
    def format_time(t):
        hours = int(t // 3600)
        minutes = int((t % 3600) // 60)
        seconds = t % 60
        return f"{hours}:{minutes:02d}:{seconds:05.2f}".replace(".",":")
    for seg in subtitles:
        start_str = format_time(seg["start"])
        end_str = format_time(seg["end"])
        text = ""
        for word in seg["textcontents"]:
            duration = int((word["end"] - word["start"]) * 100)
            if duration <= 0:
                duration = 10
            text += f"{{\\k{duration}}}{word['word']} "
        text = text.strip()
        events += f"Dialogue: 0,{start_str},{end_str},Default,,0,0,0,,{text}\n"
    with open(output_ass, "w", encoding="utf-8") as f:
        f.write(header + events)
    logging.info("ASS subtitle file exported to %s", output_ass)

def export_srt_file(subtitles, output_srt):
    srt_subs = []
    for i, seg in enumerate(subtitles):
        if "word" in seg:
            text = seg["word"]
        else:
            text = " ".join([w["word"] for w in seg["textcontents"]])
        start = timedelta(seconds=seg["start"])
        end = timedelta(seconds=seg["end"])
        srt_subs.append(srt.Subtitle(index=i+1, start=start, end=end, content=text))
    with open(output_srt, "w", encoding="utf-8") as f:
        f.write(srt.compose(srt_subs))
    logging.info("SRT subtitle file exported to %s", output_srt)

def extract_audio(input_path, audio_path="temp_audio.wav", ffmpeg_threads=4):
    try:
        subprocess.run([
            "ffmpeg", "-y", "-threads", str(ffmpeg_threads),
            "-i", input_path, "-ac", "1", "-ar", "16000", "-vn", audio_path
        ], check=True)
        return audio_path
    except subprocess.CalledProcessError as e:
        logging.error("FFmpeg extraction error: %s", e)
        QMessageBox.critical(None, "Error", f"Gagal mengekstrak audio:\n{e}")
        return None
    except Exception as e:
        logging.error("Unexpected error during audio extraction: %s", e)
        QMessageBox.critical(None, "Error", f"Error saat ekstraksi audio:\n{e}")
        return None

def transcribe_audio(audio_path, model_size, language, device_mode="auto", local_model=None):
    if device_mode.lower() == "gpu":
        device = "cuda" if torch.cuda.is_available() else "cpu"
    elif device_mode.lower() == "cpu":
        device = "cpu"
    else:
        device = "cuda" if torch.cuda.is_available() else "cpu"
    try:
        if local_model:
            if os.path.exists(local_model):
                model = whisper.load_model(local_model, device=device)
            else:
                logging.error("Local model path specified but file not found: %s", local_model)
                QMessageBox.critical(None, "Error", f"Model lokal tidak ditemukan:\n{local_model}")
                return []
        else:
            model = whisper.load_model(model_size, device=device)
        result = model.transcribe(audio_path, language=language, word_timestamps=True)
        return result["segments"]
    except Exception as e:
        logging.error("Error during transcription: %s", e)
        QMessageBox.critical(None, "Error", f"Transkripsi audio gagal:\n{e}")
        return []

def remove_punctuation(text):
    return re.sub(r'[^\w\s]', '', text)

def split_text_into_segments(data, words_per_segment):
    segments = []
    for i in range(0, len(data), words_per_segment):
        chunk = data[i:i+words_per_segment]
        segments.append({
            "word": " ".join(w["word"] for w in chunk),
            "start": chunk[0]["start"],
            "end": chunk[-1]["end"],
            "textcontents": chunk
        })
    return segments

# Fungsi create_caption: Jika break_words aktif, tiap kata akan menggunakan timestamp yang sudah dikurangi fade_out_duration
def create_caption(textJSON, framesize, placement="bottom", font="Helvetica-Bold",
                   fontsize=80, color='white', highlight_color='blue', highlight_opacity=0.8,
                   preset="Default", fadein_duration=0.3, popin_duration=0.6,
                   rounded_corner=False, stroke_enabled=False, stroke_color="black", stroke_width=0,
                   highlight_movement=False, break_words=False, fade_out_duration=0.1):
    frame_width, frame_height = framesize
    words = textJSON["textcontents"]
    text_method = "label" if stroke_enabled else "caption"
    stroke_args = {}
    if stroke_enabled:
        stroke_args["stroke_color"] = stroke_color
        stroke_args["stroke_width"] = stroke_width

    word_widths = []
    for wd in words:
        temp_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                              method=text_method, **stroke_args)
        w, _ = temp_clip.size
        word_widths.append(w)
    
    space_clip = TextClip(" ", font=font, fontsize=fontsize, color=color,
                           method=text_method, **stroke_args)
    space_width, _ = space_clip.size
    total_width = sum(word_widths) + (len(word_widths)-1)*space_width if word_widths else 0

    clips = []
    margin = frame_height * 0.1
    if placement == "top":
        base_y = margin
    elif placement == "bottom":
        base_y = frame_height - fontsize - margin
    else:
        base_y = (frame_height - fontsize) / 2

    move = (lambda t: (3 * np.sin(2 * np.pi * t/3), 5 * np.sin(2 * np.pi * t/2))) if highlight_movement else (lambda t: (0, 0))

    # get_timing: jika break_words aktif, gunakan timestamp masing-masing kata dan potong fade_out_duration
    def get_timing(wd):
        if break_words:
            effective_end = wd["end"] - fade_out_duration
            if effective_end < wd["start"]:
                effective_end = wd["start"]
            return wd["start"], effective_end - wd["start"]
        else:
            return textJSON["start"], textJSON["end"] - textJSON["start"]

    if total_width <= frame_width:
        y = base_y
        start_x = (frame_width - total_width) / 2
        current_x = start_x
        if preset == "Highlight":
            if not break_words:
                duration_seg = textJSON["end"] - textJSON["start"]
                text_clip = TextClip(textJSON["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args)
                text_clip = text_clip.set_position(lambda t: (start_x + move(t)[0], y + move(t)[1]))
                text_clip = text_clip.set_start(textJSON["start"]).set_duration(duration_seg)
            highlight_clips = []
            for idx, wd in enumerate(words):
                word_start, word_duration = get_timing(wd)
                size = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                method=text_method, **stroke_args).size
                hl_overlay = (create_rounded_overlay(size, color=highlight_color, radius=10,
                              duration=word_duration, opacity=highlight_opacity)
                              if rounded_corner else ColorClip(size, color=highlight_color, duration=word_duration).set_opacity(highlight_opacity))
                hl_overlay = hl_overlay.set_position(lambda t, cx=current_x, y=y: (cx + move(t)[0], y + move(t)[1]))
                hl_overlay = hl_overlay.set_start(word_start).set_duration(word_duration)
                highlight_clips.append(hl_overlay)
                current_x += word_widths[idx] + space_width
            clips.extend(highlight_clips)
            if not break_words:
                clips.append(text_clip)
        elif preset == "Fade In":
            for idx, wd in enumerate(words):
                word_start, word_duration = get_timing(wd)
                word_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).set_duration(word_duration)
                word_clip = word_clip.set_position((current_x, y)).set_start(word_start).set_duration(word_duration)
                from moviepy.video.fx.all import fadein
                word_clip = word_clip.fx(fadein, fadein_duration)
                clips.append(word_clip)
                current_x += word_widths[idx] + space_width
        elif preset == "Pop In":
            for idx, wd in enumerate(words):
                word_start, word_duration = get_timing(wd)
                word_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).set_duration(word_duration)
                word_clip = word_clip.set_position((current_x, y)).set_start(word_start).set_duration(word_duration)
                from moviepy.video.fx.all import resize
                scale_duration = popin_duration
                scaling = lambda t: 0.5 + 0.5 * min(t/scale_duration, 1)
                orig_size = word_clip.size
                word_clip = word_clip.fx(resize, scaling)
                word_clip = word_clip.set_position(lambda t, cx=current_x, y=y, w=orig_size[0], h=orig_size[1]:
                                                   (cx + (orig_size[0]*(1-scaling(t)))/2, y + (orig_size[1]*(1-scaling(t)))/2))
                clips.append(word_clip)
                current_x += word_widths[idx] + space_width
        elif preset == "Slide In":
            for idx, wd in enumerate(words):
                word_start, word_duration = get_timing(wd)
                word_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).set_duration(word_duration)
                slide_duration = 0.5
                word_clip = word_clip.set_position(lambda t, cx=current_x, y=y:
                                                   (cx - 50 * max(0, 1 - min(t/slide_duration, 1)), y))
                word_clip = word_clip.set_start(word_start).set_duration(word_duration)
                clips.append(word_clip)
                current_x += word_widths[idx] + space_width
        else:
            for idx, wd in enumerate(words):
                word_start, word_duration = get_timing(wd)
                word_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).set_duration(word_duration)
                word_clip = word_clip.set_position((current_x, y)).set_start(word_start).set_duration(word_duration)
                clips.append(word_clip)
                current_x += word_widths[idx] + space_width
    else:
        # Two-line wrapping
        line1_words = []
        line1_width = 0
        split_index = 0
        for idx, w in enumerate(word_widths):
            add_width = w + (space_width if idx > 0 else 0)
            if line1_width + add_width <= frame_width:
                line1_words.append(words[idx])
                line1_width += add_width
                split_index = idx + 1
            else:
                break
        line2_words = words[split_index:]
        line1_total = sum([TextClip(w["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).size[0] for w in line1_words])
        if len(line1_words) > 1:
            line1_total += space_width * (len(line1_words)-1)
        line2_total = sum([TextClip(w["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).size[0] for w in line2_words])
        if len(line2_words) > 1:
            line2_total += space_width * (len(line2_words)-1)
        spacing = fontsize * 0.25
        if placement == "top":
            y1 = margin
            y2 = margin + fontsize + spacing
        elif placement == "bottom":
            y2 = frame_height - fontsize - margin
            y1 = y2 - fontsize - spacing
        else:
            total_text_height = 2 * fontsize + spacing
            y1 = (frame_height - total_text_height) / 2
            y2 = y1 + fontsize + spacing

        x1 = (frame_width - line1_total) / 2
        current_x = x1
        if preset == "Highlight":
            if not break_words:
                duration_seg = textJSON["end"] - textJSON["start"]
                text_clip_line1 = TextClip(" ".join([w["word"] for w in line1_words]), font=font, fontsize=fontsize, color=color,
                                           method=text_method, **stroke_args)
                text_clip_line1 = text_clip_line1.set_position(lambda t: (x1 + move(t)[0], y1 + move(t)[1])).set_start(textJSON["start"]).set_duration(duration_seg)
            highlight_clips_line1 = []
            for wd in line1_words:
                word_start, word_duration = get_timing(wd)
                size = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                method=text_method, **stroke_args).size
                hl_overlay = (create_rounded_overlay(size, color=highlight_color, radius=10,
                              duration=word_duration, opacity=highlight_opacity)
                              if rounded_corner else ColorClip(size, color=highlight_color, duration=word_duration).set_opacity(highlight_opacity))
                hl_overlay = hl_overlay.set_position(lambda t, cx=current_x, y=y1: (cx + move(t)[0], y1 + move(t)[1])).set_start(word_start).set_duration(word_duration)
                highlight_clips_line1.append(hl_overlay)
                current_x += TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                        method=text_method, **stroke_args).size[0] + space_width
            clips.extend(highlight_clips_line1)
            if not break_words:
                clips.append(text_clip_line1)
        elif preset == "Fade In":
            for wd in line1_words:
                word_start, word_duration = get_timing(wd)
                word_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).set_duration(word_duration)
                word_clip = word_clip.set_position((current_x, y1)).set_start(word_start).set_duration(word_duration)
                from moviepy.video.fx.all import fadein
                word_clip = word_clip.fx(fadein, fadein_duration)
                clips.append(word_clip)
                current_x += TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                        method=text_method, **stroke_args).size[0] + space_width
        elif preset == "Pop In":
            for wd in line1_words:
                word_start, word_duration = get_timing(wd)
                word_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).set_duration(word_duration)
                word_clip = word_clip.set_position((current_x, y1)).set_start(word_start).set_duration(word_duration)
                from moviepy.video.fx.all import resize
                scale_duration = popin_duration
                scaling = lambda t: 0.5 + 0.5 * min(t/scale_duration, 1)
                orig_size = word_clip.size
                word_clip = word_clip.fx(resize, scaling)
                word_clip = word_clip.set_position(lambda t, cx=current_x, y=y1, w=orig_size[0], h=orig_size[1]:
                                                   (cx + (orig_size[0]*(1-scaling(t)))/2, y1 + (orig_size[1]*(1-scaling(t)))/2))
                clips.append(word_clip)
                current_x += TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                        method=text_method, **stroke_args).size[0] + space_width
        elif preset == "Slide In":
            for wd in line1_words:
                word_start, word_duration = get_timing(wd)
                word_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).set_duration(word_duration)
                slide_duration = 0.5
                word_clip = word_clip.set_position(lambda t, cx=current_x, y=y1:
                                                   (cx - 50 * max(0, 1 - min(t/slide_duration, 1)), y1))
                word_clip = word_clip.set_start(word_start).set_duration(word_duration)
                clips.append(word_clip)
                current_x += TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                        method=text_method, **stroke_args).size[0] + space_width
        else:
            for wd in line1_words:
                word_start, word_duration = get_timing(wd)
                word_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).set_duration(word_duration)
                word_clip = word_clip.set_position((current_x, y1)).set_start(word_start).set_duration(word_duration)
                clips.append(word_clip)
                current_x += TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                        method=text_method, **stroke_args).size[0] + space_width

        x2 = (frame_width - line2_total) / 2
        current_x = x2
        if preset == "Highlight":
            if not break_words:
                duration_seg = textJSON["end"] - textJSON["start"]
                text_clip_line2 = TextClip(" ".join([w["word"] for w in line2_words]), font=font, fontsize=fontsize, color=color,
                                           method=text_method, **stroke_args)
                text_clip_line2 = text_clip_line2.set_position(lambda t: (x2 + move(t)[0], y2 + move(t)[1])).set_start(textJSON["start"]).set_duration(duration_seg)
            highlight_clips_line2 = []
            for wd in line2_words:
                word_start, word_duration = get_timing(wd)
                size = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                method=text_method, **stroke_args).size
                hl_overlay = (create_rounded_overlay(size, color=highlight_color, radius=10, duration=word_duration, opacity=highlight_opacity)
                              if rounded_corner else ColorClip(size, color=highlight_color, duration=word_duration).set_opacity(highlight_opacity))
                hl_overlay = hl_overlay.set_position(lambda t, cx=current_x, y=y2: (cx + move(t)[0], y2 + move(t)[1])).set_start(word_start).set_duration(word_duration)
                highlight_clips_line2.append(hl_overlay)
                current_x += TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                        method=text_method, **stroke_args).size[0] + space_width
            clips.extend(highlight_clips_line2)
            if not break_words:
                clips.append(text_clip_line2)
        elif preset == "Fade In":
            for wd in line2_words:
                word_start, word_duration = get_timing(wd)
                word_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).set_duration(word_duration)
                word_clip = word_clip.set_position((current_x, y2)).set_start(word_start).set_duration(word_duration)
                from moviepy.video.fx.all import fadein
                word_clip = word_clip.fx(fadein, fadein_duration)
                clips.append(word_clip)
                current_x += TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                        method=text_method, **stroke_args).size[0] + space_width
        elif preset == "Pop In":
            for wd in line2_words:
                word_start, word_duration = get_timing(wd)
                word_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).set_duration(word_duration)
                word_clip = word_clip.set_position((current_x, y2)).set_start(word_start).set_duration(word_duration)
                from moviepy.video.fx.all import resize
                scale_duration = popin_duration
                scaling = lambda t: 0.5 + 0.5 * min(t/scale_duration, 1)
                orig_size = word_clip.size
                word_clip = word_clip.fx(resize, scaling)
                word_clip = word_clip.set_position(lambda t, cx=current_x, y=y2, w=orig_size[0], h=orig_size[1]:
                                                   (cx + (orig_size[0]*(1-scaling(t)))/2, y2 + (orig_size[1]*(1-scaling(t)))/2))
                clips.append(word_clip)
                current_x += TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                        method=text_method, **stroke_args).size[0] + space_width
        elif preset == "Slide In":
            for wd in line2_words:
                word_start, word_duration = get_timing(wd)
                word_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).set_duration(word_duration)
                slide_duration = 0.5
                word_clip = word_clip.set_position(lambda t, cx=current_x, y=y2:
                                                   (cx - 50 * max(0, 1 - min(t/slide_duration, 1)), y2))
                word_clip = word_clip.set_start(word_start).set_duration(word_duration)
                clips.append(word_clip)
                current_x += TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                        method=text_method, **stroke_args).size[0] + space_width
        else:
            for wd in line2_words:
                word_start, word_duration = get_timing(wd)
                word_clip = TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                     method=text_method, **stroke_args).set_duration(word_duration)
                word_clip = word_clip.set_position((current_x, y2)).set_start(word_start).set_duration(word_duration)
                clips.append(word_clip)
                current_x += TextClip(wd["word"], font=font, fontsize=fontsize, color=color,
                                        method=text_method, **stroke_args).size[0] + space_width

    return clips

def create_audiogram(input_video_path, wordlevel_info, output_video, framesize,
                     placement, font, fontsize, font_color, highlight_color, highlight_opacity,
                     words_per_segment, dummy, preset="Default", fadein_duration=0.3, popin_duration=0.6,
                     ffmpeg_threads=4, rounded_corner=False, lossless_quality=False, output_fps=24,
                     highlight_movement=False, stroke_enabled=False, stroke_color="black", stroke_width=0,
                     break_words=False, fade_out_duration=0.1):
    segments = split_text_into_segments(wordlevel_info, words_per_segment)
    all_text_clips = []
    for seg in segments:
        clips = create_caption(seg, framesize, placement=placement, font=font,
                               fontsize=fontsize, color=font_color, highlight_color=highlight_color,
                               highlight_opacity=highlight_opacity, preset=preset,
                               fadein_duration=fadein_duration, popin_duration=popin_duration,
                               rounded_corner=rounded_corner, stroke_enabled=stroke_enabled,
                               stroke_color=stroke_color, stroke_width=stroke_width,
                               highlight_movement=highlight_movement, break_words=break_words,
                               fade_out_duration=fade_out_duration)
        all_text_clips.extend(clips)
    ext = os.path.splitext(input_video_path)[1].lower()
    if ext in [".mp4", ".mkv", ".avi", ".mov", ".flv"]:
        background = VideoFileClip(input_video_path).resize(newsize=framesize)
    else:
        duration = segments[-1]["end"] if segments else 10
        background = ColorClip(size=framesize, color=(255, 255, 255), duration=duration)
        audio_clip = AudioFileClip(input_video_path)
        background = background.set_audio(audio_clip)
    final_video = CompositeVideoClip([background] + all_text_clips)
    if hasattr(background, "audio") and background.audio is not None:
        final_video = final_video.set_audio(background.audio)
    try:
        final_video.write_videofile(output_video, fps=output_fps, codec="libx264",
                                    audio_codec="aac", threads=ffmpeg_threads,
                                    bitrate="5000k" if not lossless_quality else None,
                                    preset="veryslow" if lossless_quality else None,
                                    ffmpeg_params=["-crf", "0"] if lossless_quality else None)
    except Exception as e:
        logging.error("Error writing video file: %s", e)
        QMessageBox.critical(None, "Error", f"Gagal membuat video:\n{e}")

def process_media(input_file, output_video, model_size, language,
                  font_color, highlight_color, placement, caps_lock, remove_punct_flag,
                  highlight_opacity, words_per_segment, preset, fadein_duration=0.3,
                  popin_duration=0.6, font="Helvetica-Bold", device_mode="auto", ffmpeg_threads=4,
                  local_model=None, output_width=720, output_height=1280, rounded_corner=False,
                  lossless_quality=False, font_size_override="Default", output_fps=24,
                  highlight_movement=False, stroke_enabled=False, stroke_color="black", stroke_width=0,
                  export_video=True, break_words=False, fade_out_duration=0.1):
    start_time = time.time()
    ext = os.path.splitext(input_file)[1].lower()
    is_video = ext in [".mp4", ".mkv", ".avi", ".mov", ".flv"]
    if is_video:
        audio_path = extract_audio(input_file, "temp_audio.wav", ffmpeg_threads)
        if not audio_path:
            return []
    else:
        audio_path = input_file
    segments = transcribe_audio(audio_path, model_size, language, device_mode=device_mode, local_model=local_model)
    wordlevel_info = []
    for seg in segments:
        for word in seg["words"]:
            txt = word["word"].strip()
            if caps_lock:
                txt = txt.upper()
            if remove_punct_flag:
                txt = remove_punctuation(txt)
            wordlevel_info.append({
                "word": txt,
                "start": word["start"],
                "end": word["end"]
            })
    if is_video and os.path.exists("temp_audio.wav"):
        try:
            os.remove("temp_audio.wav")
        except Exception as e:
            logging.warning("Failed to remove temp audio file: %s", e)
    framesize = (output_width, output_height)
    _, height = framesize
    if font_size_override != "Default":
        try:
            fontsize = int(font_size_override)
        except:
            fontsize = min(max(24, int(height / 20)), 40)
    else:
        fontsize = min(max(24, int(height / 20)), 40)
    if export_video:
        create_audiogram(input_file, wordlevel_info, output_video, framesize,
                         placement, font, fontsize, font_color, highlight_color, highlight_opacity,
                         words_per_segment, 1, preset,
                         fadein_duration=fadein_duration, popin_duration=popin_duration, ffmpeg_threads=ffmpeg_threads,
                         rounded_corner=rounded_corner, lossless_quality=lossless_quality, output_fps=output_fps,
                         highlight_movement=highlight_movement, stroke_enabled=stroke_enabled, stroke_color=stroke_color,
                         stroke_width=stroke_width, break_words=break_words, fade_out_duration=fade_out_duration)
    elapsed_time = time.time() - start_time
    logging.info("Process completed in %.2f seconds", elapsed_time)
    QMessageBox.information(None, "Selesai", "Audiogram berhasil dibuat!")
    return wordlevel_info

class SubtitleApp(QWidget):
    def __init__(self):
        super().__init__()
        self.settings = QSettings("MyCompany", "SubtitleApp")
        self.init_ui()
        self.load_settings()
    
    def init_ui(self):
        self.setWindowTitle("AI Auto Generate Subtitle Effect (Audiogram)")
        self.resize(720, 1280)
        main_layout = QVBoxLayout()
        tab_widget = QTabWidget()
        
        # Basic Tab
        basic_tab = QWidget()
        basic_layout = QVBoxLayout()
        
        group_media_output = QGroupBox("Media & Output")
        media_layout = QFormLayout()
        self.entry_media = QLineEdit()
        btn_media = QPushButton("Pilih File Media")
        btn_media.clicked.connect(self.open_media)
        media_layout.addRow("File Media:", self.entry_media)
        media_layout.addRow("", btn_media)
        self.entry_output = QLineEdit()
        btn_output = QPushButton("Simpan Output Video")
        btn_output.clicked.connect(self.save_output)
        media_layout.addRow("Output Video:", self.entry_output)
        media_layout.addRow("", btn_output)
        self.spin_out_width = QSpinBox()
        self.spin_out_width.setRange(720, 2560)
        self.spin_out_width.setValue(720)
        media_layout.addRow("Output Width:", self.spin_out_width)
        self.spin_out_height = QSpinBox()
        self.spin_out_height.setRange(720, 2560)
        self.spin_out_height.setValue(1280)
        media_layout.addRow("Output Height:", self.spin_out_height)
        group_media_output.setLayout(media_layout)
        basic_layout.addWidget(group_media_output)
        
        group_settings = QGroupBox("Basic Settings")
        settings_layout = QFormLayout()
        self.combo_language = QComboBox()
        self.combo_language.addItems(["id", "en", "es", "fr", "de", "zh", "ru", "ja"])
        self.combo_model = QComboBox()
        self.combo_model.addItems(["small", "medium", "large"])
        self.combo_font_color = QComboBox()
        self.combo_font_color.addItems(["white", "black", "red", "green", "blue", "yellow"])
        self.font_combo = QComboBox()
        self.font_combo.addItems(get_imagemagick_fonts())
        self.combo_font_size = QComboBox()
        self.combo_font_size.addItems(["Default", "Custom"])
        self.spin_custom_font_size = QSpinBox()
        self.spin_custom_font_size.setRange(8, 200)
        self.spin_custom_font_size.setValue(24)
        self.spin_custom_font_size.setEnabled(False)
        font_size_layout = QHBoxLayout()
        font_size_layout.addWidget(self.combo_font_size)
        font_size_layout.addWidget(self.spin_custom_font_size)
        self.combo_placement = QComboBox()
        self.combo_placement.addItems(["top", "middle", "bottom"])
        self.chk_caps = QCheckBox("Caps Lock All Characters")
        self.chk_remove = QCheckBox("Remove Tanda Baca")
        self.chk_stroke = QCheckBox("Enable Stroke")
        self.combo_stroke_color = QComboBox()
        self.combo_stroke_color.addItems(["black", "white", "red", "green", "blue", "yellow"])
        self.combo_stroke_color.setEnabled(False)
        self.spin_stroke_width = QSpinBox()
        self.spin_stroke_width.setRange(0, 10)
        self.spin_stroke_width.setValue(1)
        self.spin_stroke_width.setEnabled(False)
        stroke_layout = QHBoxLayout()
        stroke_layout.addWidget(self.chk_stroke)
        stroke_layout.addWidget(QLabel("Color:"))
        stroke_layout.addWidget(self.combo_stroke_color)
        stroke_layout.addWidget(QLabel("Width:"))
        stroke_layout.addWidget(self.spin_stroke_width)
        settings_layout.addRow("Bahasa:", self.combo_language)
        settings_layout.addRow("Model (Whisper):", self.combo_model)
        settings_layout.addRow("Font Color:", self.combo_font_color)
        settings_layout.addRow("Font:", self.font_combo)
        settings_layout.addRow("Font Size:", font_size_layout)
        settings_layout.addRow("Subtitle Placement:", self.combo_placement)
        settings_layout.addRow(self.chk_caps)
        settings_layout.addRow(self.chk_remove)
        settings_layout.addRow(stroke_layout)
        group_settings.setLayout(settings_layout)
        basic_layout.addWidget(group_settings)
        
        group_subtitle = QGroupBox("Subtitle Options")
        subtitle_layout = QFormLayout()
        self.combo_preset = QComboBox()
        self.combo_preset.addItems(["Default", "Fade In", "Highlight", "Pop In", "Slide In"])
        subtitle_layout.addRow("Subtitle Preset:", self.combo_preset)
        self.spin_words_per_segment = QSpinBox()
        self.spin_words_per_segment.setRange(1, 50)
        self.spin_words_per_segment.setValue(5)
        subtitle_layout.addRow("Words Per Segment:", self.spin_words_per_segment)
        self.spin_fadein_duration = QSpinBox()
        self.spin_fadein_duration.setRange(100, 2000)
        self.spin_fadein_duration.setValue(300)
        self.spin_fadein_duration.setSuffix(" ms")
        subtitle_layout.addRow("Fade In Duration:", self.spin_fadein_duration)
        self.spin_popin_duration = QSpinBox()
        self.spin_popin_duration.setRange(100, 2000)
        self.spin_popin_duration.setValue(600)
        self.spin_popin_duration.setSuffix(" ms")
        subtitle_layout.addRow("Pop In Duration:", self.spin_popin_duration)
        self.label_highlight_color = QLabel("Highlight Color:")
        self.combo_highlight_color = QComboBox()
        self.combo_highlight_color.addItems(["blue", "red", "green", "yellow", "white", "black"])
        subtitle_layout.addRow(self.label_highlight_color, self.combo_highlight_color)
        self.label_highlight_opacity = QLabel("Highlight Opacity:")
        self.spin_highlight_opacity = QDoubleSpinBox()
        self.spin_highlight_opacity.setRange(0.0, 1.0)
        self.spin_highlight_opacity.setSingleStep(0.1)
        self.spin_highlight_opacity.setValue(0.8)
        subtitle_layout.addRow(self.label_highlight_opacity, self.spin_highlight_opacity)
        self.chk_rounded_corner = QCheckBox("Rounded Corner Highlight")
        subtitle_layout.addRow(self.chk_rounded_corner)
        self.chk_highlight_movement = QCheckBox("Enable Movement")
        subtitle_layout.addRow(self.chk_highlight_movement)
        self.chk_break_words = QCheckBox("Break Words (gunakan timestamp tiap kata)")
        subtitle_layout.addRow(self.chk_break_words)
        self.spin_fade_out_duration = QDoubleSpinBox()
        self.spin_fade_out_duration.setRange(0.0, 1.0)
        self.spin_fade_out_duration.setSingleStep(0.1)
        self.spin_fade_out_duration.setValue(0.1)
        self.spin_fade_out_duration.setEnabled(self.chk_break_words.isChecked())
        subtitle_layout.addRow("Fade Out Duration:", self.spin_fade_out_duration)
        group_subtitle.setLayout(subtitle_layout)
        basic_layout.addWidget(group_subtitle)
        
        group_export = QGroupBox("Export Options")
        export_layout = QFormLayout()
        self.chk_export_video = QCheckBox("Export Video")
        self.chk_export_video.setChecked(True)
        export_layout.addRow(self.chk_export_video)
        self.chk_export_ass = QCheckBox("Export ke file .ass")
        self.entry_ass = QLineEdit()
        btn_ass = QPushButton("Pilih Lokasi .ass")
        btn_ass.clicked.connect(self.save_ass)
        export_layout.addRow(self.chk_export_ass)
        export_layout.addRow("Output .ass:", self.entry_ass)
        export_layout.addRow("", btn_ass)
        self.chk_export_srt = QCheckBox("Export ke file .srt")
        self.entry_srt = QLineEdit()
        btn_srt = QPushButton("Pilih Lokasi .srt")
        btn_srt.clicked.connect(self.save_srt)
        export_layout.addRow(self.chk_export_srt)
        export_layout.addRow("Output .srt:", self.entry_srt)
        export_layout.addRow("", btn_srt)
        group_export.setLayout(export_layout)
        basic_layout.addWidget(group_export)
        
        group_process = QGroupBox("Process")
        process_layout = QVBoxLayout()
        self.btn_process = QPushButton("Proses & Buat Audiogram")
        self.btn_process.clicked.connect(self.run_process)
        self.progress_bar = QProgressBar()
        process_layout.addWidget(self.btn_process)
        process_layout.addWidget(self.progress_bar)
        group_process.setLayout(process_layout)
        basic_layout.addWidget(group_process)
        
        basic_tab.setLayout(basic_layout)
        scroll_basic = QScrollArea()
        scroll_basic.setWidget(basic_tab)
        scroll_basic.setWidgetResizable(True)
        scroll_basic.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_basic.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        # System Tab
        system_tab = QWidget()
        system_layout = QVBoxLayout()
        group_system = QGroupBox("System Settings")
        system_form = QFormLayout()
        self.entry_imagemagick = QLineEdit()
        self.entry_imagemagick.setText(DEFAULT_IMAGEMAGICK_PATH)
        btn_imagemagick = QPushButton("Pilih ImageMagick")
        btn_imagemagick.clicked.connect(self.open_imagemagick)
        system_form.addRow("ImageMagick Path:", self.entry_imagemagick)
        system_form.addRow("", btn_imagemagick)
        self.entry_local_model = QLineEdit()
        btn_local_model = QPushButton("Pilih Model Lokal")
        btn_local_model.clicked.connect(self.open_local_model)
        system_form.addRow("Local Model Whisper:", self.entry_local_model)
        system_form.addRow("", btn_local_model)
        self.spin_ffmpeg_threads = QSpinBox()
        self.spin_ffmpeg_threads.setRange(1, 16)
        self.spin_ffmpeg_threads.setValue(4)
        system_form.addRow("FFMPEG Threads:", self.spin_ffmpeg_threads)
        group_system.setLayout(system_form)
        system_layout.addWidget(group_system)
        system_tab.setLayout(system_layout)
        
        scroll_system = QScrollArea()
        scroll_system.setWidget(system_tab)
        scroll_system.setWidgetResizable(True)
        scroll_system.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_system.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        # Advanced Tab
        advanced_tab = QWidget()
        advanced_layout = QVBoxLayout()
        group_quality = QGroupBox("Output Quality Options")
        quality_layout = QFormLayout()
        self.chk_lossless = QCheckBox("Lossless Output Quality")
        quality_layout.addRow(self.chk_lossless)
        group_quality.setLayout(quality_layout)
        
        group_fps = QGroupBox("Custom Output FPS")
        fps_layout = QFormLayout()
        self.chk_custom_fps = QCheckBox("Custom FPS")
        self.combo_fps = QComboBox()
        self.combo_fps.addItems(["30", "60", "90", "144"])
        self.combo_fps.setEnabled(False)
        fps_layout.addRow(self.chk_custom_fps)
        fps_layout.addRow("FPS:", self.combo_fps)
        group_fps.setLayout(fps_layout)
        
        advanced_layout.addWidget(group_quality)
        advanced_layout.addWidget(group_fps)
        advanced_tab.setLayout(advanced_layout)
        
        scroll_advanced = QScrollArea()
        scroll_advanced.setWidget(advanced_tab)
        scroll_advanced.setWidgetResizable(True)
        scroll_advanced.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_advanced.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        tab_widget.addTab(scroll_basic, "Basic")
        tab_widget.addTab(scroll_system, "System")
        tab_widget.addTab(scroll_advanced, "Advanced")
        main_layout.addWidget(tab_widget)
        self.setLayout(main_layout)
        
        self.combo_font_size.currentIndexChanged.connect(self.on_font_size_option_changed)
        self.chk_custom_fps.stateChanged.connect(self.on_custom_fps_changed)
        self.combo_preset.currentIndexChanged.connect(self.update_preset_controls)
        self.chk_stroke.stateChanged.connect(self.on_stroke_changed)
        self.chk_break_words.stateChanged.connect(lambda: self.spin_fade_out_duration.setEnabled(self.chk_break_words.isChecked()))
        self.update_preset_controls()
    
    def on_font_size_option_changed(self):
        if self.combo_font_size.currentText() == "Custom":
            self.spin_custom_font_size.setEnabled(True)
        else:
            self.spin_custom_font_size.setEnabled(False)
    
    def on_custom_fps_changed(self):
        self.combo_fps.setEnabled(self.chk_custom_fps.isChecked())
    
    def on_stroke_changed(self):
        enabled = self.chk_stroke.isChecked()
        self.combo_stroke_color.setEnabled(enabled)
        self.spin_stroke_width.setEnabled(enabled)
    
    def update_preset_controls(self):
        preset = self.combo_preset.currentText()
        if preset == "Fade In":
            self.spin_fadein_duration.setEnabled(True)
            self.spin_popin_duration.setEnabled(False)
            self.label_highlight_color.setEnabled(False)
            self.combo_highlight_color.setEnabled(False)
            self.label_highlight_opacity.setEnabled(False)
            self.spin_highlight_opacity.setEnabled(False)
            self.chk_rounded_corner.setEnabled(False)
            self.chk_highlight_movement.setEnabled(False)
        elif preset == "Pop In":
            self.spin_fadein_duration.setEnabled(False)
            self.spin_popin_duration.setEnabled(True)
            self.label_highlight_color.setEnabled(False)
            self.combo_highlight_color.setEnabled(False)
            self.label_highlight_opacity.setEnabled(False)
            self.spin_highlight_opacity.setEnabled(False)
            self.chk_rounded_corner.setEnabled(False)
            self.chk_highlight_movement.setEnabled(False)
        elif preset == "Highlight":
            self.spin_fadein_duration.setEnabled(False)
            self.spin_popin_duration.setEnabled(False)
            self.label_highlight_color.setEnabled(True)
            self.combo_highlight_color.setEnabled(True)
            self.label_highlight_opacity.setEnabled(True)
            self.spin_highlight_opacity.setEnabled(True)
            self.chk_rounded_corner.setEnabled(True)
            self.chk_highlight_movement.setEnabled(True)
        elif preset == "Slide In":
            self.spin_fadein_duration.setEnabled(False)
            self.spin_popin_duration.setEnabled(False)
            self.label_highlight_color.setEnabled(False)
            self.combo_highlight_color.setEnabled(False)
            self.label_highlight_opacity.setEnabled(False)
            self.spin_highlight_opacity.setEnabled(False)
            self.chk_rounded_corner.setEnabled(False)
            self.chk_highlight_movement.setEnabled(False)
        else:
            self.spin_fadein_duration.setEnabled(False)
            self.spin_popin_duration.setEnabled(False)
            self.label_highlight_color.setEnabled(False)
            self.combo_highlight_color.setEnabled(False)
            self.label_highlight_opacity.setEnabled(False)
            self.spin_highlight_opacity.setEnabled(False)
            self.chk_rounded_corner.setEnabled(False)
            self.chk_highlight_movement.setEnabled(False)
    
    def open_media(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Pilih File Media", "",
            "Media Files (*.mp4 *.mkv *.avi *.mov *.flv *.mp3 *.wav)"
        )
        if file_path:
            self.entry_media.setText(file_path)
    
    def save_output(self):
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Simpan Output Video", "",
            "Video Files (*.mp4)"
        )
        if file_path:
            self.entry_output.setText(file_path)
    
    def open_imagemagick(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Pilih File Executable ImageMagick", "",
            "Executable Files (*.exe)"
        )
        if file_path:
            self.entry_imagemagick.setText(file_path)
            self.font_combo.clear()
            self.font_combo.addItems(get_imagemagick_fonts(file_path))
    
    def open_local_model(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Pilih File Model Whisper", "",
            "Model Files (*.pt *.pth);;All Files (*)"
        )
        if file_path:
            self.entry_local_model.setText(file_path)
    
    def save_ass(self):
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Simpan File Subtitle (.ass)", "",
            "ASS Files (*.ass)"
        )
        if file_path:
            self.entry_ass.setText(file_path)
    
    def save_srt(self):
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Simpan File Subtitle (.srt)", "",
            "SRT Files (*.srt)"
        )
        if file_path:
            self.entry_srt.setText(file_path)
    
    def run_process(self):
        input_file = self.entry_media.text().strip()
        output_video = self.entry_output.text().strip()
        if not input_file or (self.chk_export_video.isChecked() and not output_video):
            QMessageBox.critical(self, "Error", "Pastikan file media dan output video telah dipilih (jika export video dicentang).")
            return
        out_width = self.spin_out_width.value()
        out_height = self.spin_out_height.value()
        if self.chk_custom_fps.isChecked():
            output_fps = int(self.combo_fps.currentText())
        else:
            output_fps = 24
        params = {
            "input_file": input_file,
            "output_video": output_video,
            "model_size": self.combo_model.currentText(),
            "language": self.combo_language.currentText(),
            "font_color": self.combo_font_color.currentText(),
            "highlight_color": self.combo_highlight_color.currentText(),
            "placement": self.combo_placement.currentText(),
            "caps_lock": self.chk_caps.isChecked(),
            "remove_punct_flag": self.chk_remove.isChecked(),
            "highlight_opacity": self.spin_highlight_opacity.value(),
            "words_per_segment": self.spin_words_per_segment.value(),
            "preset": self.combo_preset.currentText(),
            "fadein_duration": self.spin_fadein_duration.value() / 1000.0,
            "popin_duration": self.spin_popin_duration.value() / 1000.0,
            "font": self.font_combo.currentText(),
            "device_mode": "auto",
            "ffmpeg_threads": self.spin_ffmpeg_threads.value(),
            "local_model": self.entry_local_model.text().strip() if self.entry_local_model.text().strip() else None,
            "output_width": out_width,
            "output_height": out_height,
            "rounded_corner": self.chk_rounded_corner.isChecked(),
            "lossless_quality": self.chk_lossless.isChecked(),
            "font_size_override": self.spin_custom_font_size.value() if self.combo_font_size.currentText() == "Custom" else "Default",
            "output_fps": output_fps,
            "highlight_movement": self.chk_highlight_movement.isChecked(),
            "stroke_enabled": self.chk_stroke.isChecked(),
            "stroke_color": self.combo_stroke_color.currentText(),
            "stroke_width": self.spin_stroke_width.value(),
            "export_video": self.chk_export_video.isChecked(),
            "break_words": self.chk_break_words.isChecked(),
            "fade_out_duration": self.spin_fade_out_duration.value()
        }
        global IMAGEMAGICK_PATH
        IMAGEMAGICK_PATH = self.entry_imagemagick.text().strip()
        cfg.change_settings({"IMAGEMAGICK_BINARY": IMAGEMAGICK_PATH})
        self.font_combo.clear()
        self.font_combo.addItems(get_imagemagick_fonts(IMAGEMAGICK_PATH))
        self.btn_process.setEnabled(False)
        self.progress_bar.setValue(0)
        subtitle_data = process_media(**params)
        self.progress_bar.setValue(100)
        self.btn_process.setEnabled(True)
        if self.chk_export_ass.isChecked():
            lines = split_text_into_segments(subtitle_data, self.spin_words_per_segment.value())
            export_ass_file(lines, self.entry_ass.text().strip(), playresx=out_width, playresy=out_height,
                            font=self.font_combo.currentText(), fontsize=min(max(24, int(out_height/20)), 40))
        if self.chk_export_srt.isChecked():
            lines = split_text_into_segments(subtitle_data, self.spin_words_per_segment.value())
            export_srt_file(lines, self.entry_srt.text().strip())
    
    def load_settings(self):
        self.entry_media.setText(self.settings.value("media_file", ""))
        self.entry_output.setText(self.settings.value("output_file", ""))
        self.combo_language.setCurrentText(self.settings.value("language", "id"))
        self.combo_model.setCurrentText(self.settings.value("model", "small"))
        self.combo_font_color.setCurrentText(self.settings.value("font_color", "white"))
        self.font_combo.setCurrentText(self.settings.value("font", "Helvetica-Bold"))
        font_size_value = self.settings.value("font_size_override", "Default")
        if font_size_value == "Default":
            self.combo_font_size.setCurrentText("Default")
            self.spin_custom_font_size.setEnabled(False)
        else:
            self.combo_font_size.setCurrentText("Custom")
            try:
                self.spin_custom_font_size.setValue(int(font_size_value))
            except:
                self.spin_custom_font_size.setValue(24)
            self.spin_custom_font_size.setEnabled(True)
        self.combo_placement.setCurrentText(self.settings.value("placement", "bottom"))
        self.chk_caps.setChecked(self.settings.value("caps_lock", False, type=bool))
        self.chk_remove.setChecked(self.settings.value("remove_punct_flag", False, type=bool))
        self.chk_export_ass.setChecked(self.settings.value("export_ass", False, type=bool))
        self.entry_ass.setText(self.settings.value("ass_file", ""))
        self.chk_export_srt.setChecked(self.settings.value("export_srt", False, type=bool))
        self.entry_srt.setText(self.settings.value("srt_file", ""))
        self.chk_export_video.setChecked(self.settings.value("export_video", True, type=bool))
        self.entry_imagemagick.setText(self.settings.value("imagemagick_path", DEFAULT_IMAGEMAGICK_PATH))
        self.entry_local_model.setText(self.settings.value("local_model", ""))
        self.spin_ffmpeg_threads.setValue(int(self.settings.value("ffmpeg_threads", 4)))
        self.spin_out_width.setValue(int(self.settings.value("out_width", 720)))
        self.spin_out_height.setValue(int(self.settings.value("out_height", 1280)))
        self.chk_lossless.setChecked(self.settings.value("lossless_quality", False, type=bool))
        custom_fps = self.settings.value("custom_fps_enabled", False, type=bool)
        self.chk_custom_fps.setChecked(custom_fps)
        self.combo_fps.setEnabled(custom_fps)
        self.combo_fps.setCurrentText(self.settings.value("output_fps", "24"))
        self.chk_highlight_movement.setChecked(self.settings.value("highlight_movement", False, type=bool))
        self.chk_stroke.setChecked(self.settings.value("stroke_enabled", False, type=bool))
        self.combo_stroke_color.setCurrentText(self.settings.value("stroke_color", "black"))
        self.spin_stroke_width.setValue(int(self.settings.value("stroke_width", 1)))
        self.chk_break_words.setChecked(self.settings.value("break_words", False, type=bool))
        self.spin_fade_out_duration.setValue(float(self.settings.value("fade_out_duration", 0.1)))
        self.spin_fade_out_duration.setEnabled(self.chk_break_words.isChecked())
    
    def save_settings(self):
        self.settings.setValue("media_file", self.entry_media.text())
        self.settings.setValue("output_file", self.entry_output.text())
        self.settings.setValue("language", self.combo_language.currentText())
        self.settings.setValue("model", self.combo_model.currentText())
        self.settings.setValue("font_color", self.combo_font_color.currentText())
        self.settings.setValue("font", self.font_combo.currentText())
        if self.combo_font_size.currentText() == "Custom":
            self.settings.setValue("font_size_override", self.spin_custom_font_size.value())
        else:
            self.settings.setValue("font_size_override", "Default")
        self.settings.setValue("placement", self.combo_placement.currentText())
        self.settings.setValue("caps_lock", self.chk_caps.isChecked())
        self.settings.setValue("remove_punct_flag", self.chk_remove.isChecked())
        self.settings.setValue("export_ass", self.chk_export_ass.isChecked())
        self.settings.setValue("ass_file", self.entry_ass.text())
        self.settings.setValue("export_srt", self.chk_export_srt.isChecked())
        self.settings.setValue("srt_file", self.entry_srt.text())
        self.settings.setValue("export_video", self.chk_export_video.isChecked())
        self.settings.setValue("imagemagick_path", self.entry_imagemagick.text())
        self.settings.setValue("local_model", self.entry_local_model.text())
        self.settings.setValue("ffmpeg_threads", self.spin_ffmpeg_threads.value())
        self.settings.setValue("out_width", self.spin_out_width.value())
        self.settings.setValue("out_height", self.spin_out_height.value())
        self.settings.setValue("lossless_quality", self.chk_lossless.isChecked())
        self.settings.setValue("custom_fps_enabled", self.chk_custom_fps.isChecked())
        self.settings.setValue("output_fps", self.combo_fps.currentText())
        self.settings.setValue("highlight_movement", self.chk_highlight_movement.isChecked())
        self.settings.setValue("stroke_enabled", self.chk_stroke.isChecked())
        self.settings.setValue("stroke_color", self.combo_stroke_color.currentText())
        self.settings.setValue("stroke_width", self.spin_stroke_width.value())
        self.settings.setValue("break_words", self.chk_break_words.isChecked())
        self.settings.setValue("fade_out_duration", self.spin_fade_out_duration.value())
    
    def closeEvent(self, event):
        self.save_settings()
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = SubtitleApp()
    window.show()
    sys.exit(app.exec())
